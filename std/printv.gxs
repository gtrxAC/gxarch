; ______________________________________________________________________________
;
;  Print subroutine (for variable width fonts)
;
;  Arguments:
;    %20 %21 = address of string to print
;    %22 = X position to print at
;    %23 = Y position
;
;  Constants (need to be defined before including this file):
;    PRINTV_CHARSPERLINE = how many chars are on each line in the tileset
;    PRINTV_WIDTH = maximum width of each character (how much space each char
;                   takes up in the tileset, even if not all of the space is
;                   used)
;    PRINTV_HEIGHT = height of each character
;    printv_charwidths = width of each character, in ASCII order, starting at
;                        null (see examples/vfont.gxs)
;
;  Uses registers:
;    %24 = current character being printed
;    %25 = character source X position in tileset
;    %26 = character source Y
;
;  Notes:
;  - In the tileset, the characters must start at (0, 0), in ASCII order,
;    starting at null (the first row is empty, assuming PRINT_WIDTH = 4).
;    You should use the default tileset assets/tilesetv.png as a base for your
;    own tileset if you're using the default parameters (32 chars per line,
;    width 4, height 8, charwidths from examples/vfont.gxs).
;  - This subroutine doesn't do line wrapping, everything is drawn on one line.
;  - The registers %20 %21 %22 are overwritten, copy them to other registers
;    using the .mov macro if you need to use them after calling print.
; ______________________________________________________________________________
;
.include std/common.gxs

printv: {
	reg strh arg0    ; address of string, high byte
	reg strl arg1    ; low byte
	reg x arg2       ; X print location (gets overwritten)
	reg y arg3       ; Y print location
	reg curchar %24  ; current character value being drawn
	reg sx %25       ; current char X location in tileset
	reg sy %26       ; current char Y location in tileset
	reg sw %27       ; current character width
	reg chrwh %2     ; address of current character width, high (charwidths)
	reg chrwl %3     ; address of current character width, low

	ldi curchar strh       ; load character
	cj curchar printvdraw  ; if not null term, continue
	ret
printvdraw:
	set %0 PRINTV_CHARSPERLINE  ; source Y = char / chars per line
	div curchar %0 sy
	set %0 0                   ; source X = division remainder
	add %r %0 sx

	set %0 PRINTV_WIDTH
	set %1 PRINTV_HEIGHT
	mul sx %0 sx         ; source X *= character width
	mul sy %1 sy         ; source Y *= character height

	set chrwh hi(printv_charwidths)  ; get width of current char
	set chrwl lo(printv_charwidths)
	add chrwl curchar chrwl
	add chrwh %h chrwh
	ldi %0 chrwh

	dw sx sy %0 %1  ; draw character
	at x y

	set %2 1          ; go to next character
	add strl %2 strl
	add strh %h strh

	add x %0 x  ; next character cell
	jmp printv
}