<!DOCTYPE html>
<html>
	<head>
		<title>gxVM.js</title>
		<style>
			body {
				background-color: #080b0f;
				font-family: monospace;
				margin: 0;
			}
			#err {
				background-color: #f24;
				color: white;
				padding: 1em;
				display: none;
				display: block; /* gxa_builder_remove */
			}
			#screen {
				margin: 1em;
				display: flex;
				justify-content: center;
			}
			#fps {
				color: #ffffff20;
			}
			canvas {
				image-rendering: pixelated;
			}
		</style>
	</head>
	<body>
		<!-- Invisible canvas for the image so it can be loaded as a tileset -->
		<div style="display: none;">
			<!-- gxa_builder_tileset_here -->
		</div>
		<div id="err">
			This file won't do anything by itself - use builder.js to create HTML files from gxarch programs. <!-- gxa_builder_remove -->
		</div>
		<div id="fps"></div>
		<div id="screen">
			<canvas width="128" height="128"></canvas><br>
		</div>
		<script type="text/javascript">
			'use strict';
			const canvas = document.querySelector('canvas');
			const tileset = document.querySelector('img');
			const fpsmeter = document.getElementById('fps');
			const ctx = canvas.getContext('2d');
			let scale;
			let state;

			ctx.fillStyle = 'black';

			// gxa_builder_code_here

			function err(msg) {
				const el = document.getElementById('err');
				el.style.display = 'block';
				el.innerHTML = `<b>Error</b> ${msg}`;
				throw new Error(msg);
			}

			const pressedkeys = [];

			// https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values
			// capslock/shift
			const keymap = new Map() // key = browser keycode  value = gxarch keycode
			.set('Alt', 0x13)
			.set('Control', 0x11)
			.set('Meta', 0x12)  // 0x12 = Windows key
			.set('Super', 0x12)
			.set('OS', 0x12)
			.set('Enter', 0x0a)
			.set('Tab', 0x09)
			.set(' ', 0x20)
			.set('ArrowUp', 0x8c)
			.set('ArrowLeft', 0x8d)
			.set('ArrowDown', 0x8e)
			.set('ArrowRight', 0x8f)
			.set('Backspace', 0x08)
			.set('Escape', 0x1b)

			for (let i = 1; i < 13; i++) {
				keymap.set(`F${i}`, 0x7f + i);
			}

			const ops = {
				NOP: 0, SET: 1, LD: 2, LDI: 3, ST: 4, STI: 5,
				ADD: 6, SUB: 7, MUL: 8, DIV: 9,
				AND: 10, OR: 11, XOR: 12,
				EQ: 13, LT: 14, GT: 15,
				JMP: 16, CJ: 17, JS: 18, CJS: 19, RET: 20,
				DW: 21, AT: 22, KEY: 23, SND: 24, END: 25,
				COUNT: 26
			};

			const constants = {
				ENTRY: 0x0000,
				SRAM: 0xF000,
				RESERVED: 0xFF00,
				MOUSEX: 0xFF01,
				MOUSEY: 0xFF02,
				MOUSEL: 0xFF03,
				MOUSER: 0xFF04,
				SRAM_TOGGLE: 0xFF05,
				RAND: 0xFF06,

				RESH: 30,
				REMAINDER: 31,

				SCREENW: 128,
				SCREENH: 128
			}

			const states = {
				RUNNING: 0,
				PAUSED: 1
			}

			class VM {
				constructor() {
					this.membuf = new ArrayBuffer(0x10000);
					this.mem = new DataView(this.membuf);
					
					this.reg = new Uint8Array(32);
					this.callstack = [];
					this.pc = 0;
					this.drawX = 0;
					this.drawY = 0;
					this.drawwidth = 0;
					this.drawheight = 0;
					this.needdraw = false;
				}

				get8(addr) { return this.mem.getUint8(addr); }
				get16(addr) { return this.mem.getUint16(addr); }
				set8(addr, val) { return this.mem.setUint8(addr, val); }
				set16(addr, val) { return this.mem.setUint16(addr, val); }
				consume() { return this.mem.getUint8(this.pc++); }

				consume16() { return this.consume() << 8 | this.consume(); }

				step() {
					if (this.pc < 2 || this.pc >= constants.RESERVED)
						err(`Attempted to execute code at 0x${this.pc.toString(16)}`);

					const op = this.consume();

					if (op >= ops.COUNT)
						err(`Invalid opcode at 0x${(this.pc - 1).toString(16)}: ${op}`);

					switch (op) {
						case ops.NOP: break;

						case ops.SET: {
							const reg = this.consume();
							this.reg[reg] = this.consume();
							break;
						}

						case ops.LD: {
							const reg = this.consume();
							const addr = this.consume16();
							this.reg[reg] = this.get8(addr);
							if (addr == constants.RAND)
								this.set8(constants.RAND, Math.floor(Math.random() * 256));
							break;
						}

						case ops.LDI: {
							const dest = this.consume();
							const src = this.consume();
							const addr = this.reg[src] << 8 | this.reg[src + 1];
							this.reg[dest] = this.get8(addr);
							break;
						}

						case ops.ST: {
							const val = this.reg[this.consume()];
							const addr = this.consume16();
							this.set8(addr, val);
							if (addr == constants.SRAM_TOGGLE && val) this.load();
							if (addr >= constants.SRAM && addr < constants.RESERVED)
								localStorage.setItem(addr, val);
							break;
						}

						case ops.STI: {
							const val = this.reg[this.consume()];
							const reg = this.consume();
							const addr = this.reg[reg] << 8 | this.reg[reg + 1];
							this.set8(addr, val);
							if (addr == constants.SRAM_TOGGLE && val) this.load();
							if (addr >= constants.SRAM && addr < constants.RESERVED)
								localStorage.setItem(addr, val);
							break;
						}

						case ops.ADD: {
							const result = this.reg[this.consume()] + this.reg[this.consume()];
							this.reg[this.consume()] = result & 0xFF;
							this.reg[constants.RESH] = (result & 0xFF00) >> 8;
							break;
						}

						case ops.SUB: {
							const result = this.reg[this.consume()] - this.reg[this.consume()];
							this.reg[this.consume()] = result & 0xFF;
							this.reg[constants.RESH] = (result & 0xFF00) >> 8;
							break;
						}

						case ops.MUL: {
							const result = this.reg[this.consume()] * this.reg[this.consume()];
							this.reg[this.consume()] = result & 0xFF;
							this.reg[constants.RESH] = (result & 0xFF00) >> 8;
							break;
						}
						
						case ops.DIV: {
							const first = this.reg[this.consume()];
							const second = this.reg[this.consume()];
							if (!second)
								err(`Division by zero at 0x${(this.pc - 3).toString(16)}`);

							this.reg[this.consume()] = Math.floor(first / second) & 0xFF;
							this.reg[constants.REMAINDER] = first % second;
							break;
						}
						
						case ops.AND: {
							const result = this.reg[this.consume()] & this.reg[this.consume()];
							this.reg[this.consume()] = result;
							break;
						}

						case ops.OR: {
							const result = this.reg[this.consume()] | this.reg[this.consume()];
							this.reg[this.consume()] = result;
							break;
						}

						case ops.XOR: {
							const result = this.reg[this.consume()] ^ this.reg[this.consume()];
							this.reg[this.consume()] = result;
							break;
						}

						case ops.EQ: {
							const result = this.reg[this.consume()] === this.reg[this.consume()];
							this.reg[this.consume()] = result;
							break;
						}

						case ops.LT: {
							const result = this.reg[this.consume()] < this.reg[this.consume()];
							this.reg[this.consume()] = result;
							break;
						}

						case ops.GT: {
							const result = this.reg[this.consume()] > this.reg[this.consume()];
							this.reg[this.consume()] = result;
							break;
						}

						case ops.JMP:
							this.pc = this.consume16();
							break;

						case ops.CJ: {
							const cond = this.reg[this.consume()];
							const addr = this.consume16();
							if (cond) this.pc = addr;
							break;
						}

						case ops.JS: {
							const addr = this.consume16();
							this.callstack.push(this.pc);
							this.pc = addr;
							break;
						}

						case ops.CJS: {
							const cond = this.reg[this.consume()];
							const addr = this.consume16();
							if (cond) {
								this.callstack.push(this.pc);
								this.pc = addr;
							}
							break;
						}

						case ops.RET:
							this.pc = this.callstack.pop();
							break;

						case ops.DW:
							this.drawX = this.reg[this.consume()] % 128; // drawscroll won't work if we don't do % 128
							this.drawY = this.reg[this.consume()] % 128;
							this.drawwidth = this.reg[this.consume()];
							this.drawheight = this.reg[this.consume()];
							break;
							
						case ops.AT: {
							const x = this.reg[this.consume()];
							const y = this.reg[this.consume()];

							ctx.drawImage(
								tileset, this.drawX, this.drawY, this.drawwidth, this.drawheight,
								x, y, this.drawwidth, this.drawheight
							);
							if (this.drawX + this.drawwidth > tileset.width) {
								ctx.drawImage(
									tileset, 0, this.drawY, this.drawX, this.drawheight,
									tileset.width - this.drawX, y,
									this.drawX, this.drawheight
								)
							}
							if (this.drawY + this.drawheight > tileset.height) {
								ctx.drawImage(
									tileset, this.drawX, 0, this.drawwidth, this.drawY,
									x, tileset.height - this.drawY,
									this.drawwidth, this.drawY
								)

								if (this.drawX + this.drawwidth > tileset.width) {
									ctx.drawImage(
										tileset, 0, 0, this.drawX, this.drawY,
										tileset.width - this.drawX, tileset.height - this.drawY,
										this.drawX, this.drawY
									)
								}
							}
							break;
						}

						case ops.KEY: {
							let key = this.reg[this.consume()];
							this.reg[this.consume()] = Number(pressedkeys[key] ?? false);
							break;
						}
						
						case ops.SND:
							err(`SND not implemented, used at 0x${(this.pc - 1).toString(16)}`);
							break;

						case ops.END:
							this.needdraw = true;
							break;
					}
				}

				// saving is done immediately when writing to SRAM with st and sti instructions
				load() {
					for (let i = constants.SRAM; i < constants.RESERVED; i++) {
						vm.set8(i, localStorage.getItem(i));
					}
				}
			}

			const vm = new VM();
			
			canvas.onmousemove = event => {
				vm.set8(constants.MOUSEX, Math.floor(event.offsetX / scale));
				vm.set8(constants.MOUSEY, Math.floor(event.offsetY / scale));
			}
			document.addEventListener('mouseup', e => {
				if (e.button === 0) vm.set8(constants.MOUSEL, 0);
				else if (e.button === 2) vm.set8(constants.MOUSER, 0);
			});
			document.addEventListener('mousedown', e => {
				if (e.button === 0) vm.set8(constants.MOUSEL, 1);
				else if (e.button === 2) vm.set8(constants.MOUSER, 1);
			});
			document.addEventListener('keyup', e => {
				let code = keymap.get(e.code);

				if (code === undefined) {
					if (e.key.length > 1) return;
					code = e.key.charCodeAt(0);
				}
				pressedkeys[code] = false;
			})
			document.addEventListener('keydown', e => {
				let code = keymap.get(e.code);

				if (code === undefined) {
					if (e.key.length > 1) return;
					code = e.key.charCodeAt(0);
				}
				pressedkeys[code] = true;
			})

			onresize = () => {
				// Integer scale the screen to fit the window.
				scale = Math.min(
					Math.floor(innerWidth / canvas.width),
					Math.floor(innerHeight / canvas.height)
				)
				
				// If the screen is too small, allow fractional scaling.
				|| Math.min(
					innerWidth / canvas.width,
					innerHeight / canvas.height
				)
				
				canvas.style.imageRendering = (scale % 1 ? 'unset' : 'pixelated');
				canvas.style.width = canvas.width * scale + 'px';
				canvas.style.height = canvas.height * scale + 'px';
			}

			onload = () => {
				if (rom.length > 0xFF00)
					err(`ROM too large, 0x${rom.length.toString(16)} > 0xFF00`);

				rom.forEach((byte, i) => vm.set8(i, byte))
				vm.pc = vm.get16(0x0000);
				vm.set8(constants.RAND, Math.floor(Math.random() * 256));

				state = states.RUNNING;
				onresize();
			}

			setInterval(() => {
				let start = Date.now();

				if (state === states.RUNNING) {
					ctx.fillRect(0, 0, 128, 128);
					while (!vm.needdraw) vm.step();
				}

				vm.needdraw = false;
				let frametime = Date.now() - start;
				fpsmeter.innerHTML = `frame: ${frametime}ms`;
			}, 1000 / 60)
		</script>
	</body>
</html>