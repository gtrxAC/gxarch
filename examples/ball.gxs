; Ball for gxarch
; Draws a bouncing ball on screen, which can be moved using the mouse
; Date: 2021-12-22
; Author: gtrxAC

dat main

.include std/common.gxs

; Main memory is not used, all variables are stored in registers:
; %10 = X position (randomized at start)
; %11 = Y position
; %12 = X delta (how many pixels the ball moves each frame)
; %13 = Y delta
; %14 = coordinates of screen right edge (constant 126)
; %15 = coordinates of screen bottom edge (constant 118)
; %16 = current animation frame (changes when hitting edges)
; %17 = constant 0
; %18 = ball size (constant 3)

reg x %10
reg y %11
reg dx %12
reg dy %13
reg REDGE %14
reg BEDGE %15
reg anim %16
reg _0 %17
reg BSZ %18

main:
	set %0 2
	ld x RAND   ; generate random start position
	ld y RAND
	div x %0 x  ; RAND is 0-255, but screen is only 128 pixels, so divide by 2
	div y %0 y

	set dx 1
	set dy 1
	set REDGE 126  ; screen edges are not the same as screen resolution, because:
	set BEDGE 118  ; - if it were 128, the ball would be partially off screen when
	set BSZ 3      ;   hitting the bottom and right edges
	               ; - if both X and Y were the same, the ball's movement would
	               ;   always be the same and very repetitive

update:
	ld %0 MOUSEL
	cjs %0 gotomouse

	add x dx x           ; ball X += X delta
	.gtjs x REDGE right  ; if hit right edge, set delta X to -1 (255 in unsigned)
	.eqjs x _0 left      ; if hit left edge, set delta X to 1
	add y dy y           ; ball Y += Y delta
	.gtjs y BEDGE down   ; if hit bottom edge, set delta Y to -1
	.eqjs y _0 up        ; if hit top edge, set delta Y to 1

draw:
	dw anim _0 BSZ BSZ
	at x y
	end
	jmp update

right:
	set dx 255
	js nextframe
	ret

left:
	set dx 1
	js nextframe
	ret

down:
	set dy 255
	js nextframe
	ret

up:
	set dy 1
	; js nextframe
	; ret

nextframe:
	set %1 24
	add anim BSZ anim
	.eqj anim %1 resetframe
	ret

resetframe:
	set anim 0
	ret

gotomouse:
	ld x MOUSEX
	ld y MOUSEY
	ret