;wip

; Window Manager for gxarch
; Date: 2021-12-12
; Author: gtrxAC

; This example is still very work in progress. It doesn't work with the current assembler and doesn't work on web.

; What works: drawing and closing windows
; What doesn't work: moving, resizing, focusing and creating new windows
; Note: You'll need to create your own save file to use this! Otherwise you'll
;       just get a tiled wallpaper. There is a wm.sav.bin which you can rename
;       to wm.sav.

dat main

; Computed jumps (uses self modifying code)
; Note: these should be placed right after "dat main"

compjmp:    ; Jump to a computed address (replace %x %y):
	jmp     ; st %x compjmph
	0x0000  ; st %y compjmpl
	        ; jmp compjmp

compjs:     ; Call a sub at a computed address (replace %x %y):
	js      ; st %x compjsh
	0x0000  ; st %y compjsl
	ret     ; js compjs

val compjmph 0x0003
val compjmpl 0x0004
val compjsh 0x0006
val compjsl 0x0007

; ______________________________________________________________________________
;

;      __ Window slot
;     |
;     v
; 0xE0_0: X position
; 0xE0_1: Y position
; 0xE0_2: width
; 0xE0_3: height
; 0xE0_4: is window slot in use?
; 0xE0_5: address of window update subroutine (2 bytes)
; 0xE0_7: title (8 bytes + null terminator)

val WINCOUNT 16
val WINADDR 0xF000
val WINSTRUCTSIZE 16

val WINY 1
val WINW 2
val WINH 3
val WINACTIVE 4
val WINFUNC 5
val WINTITLE 7

val PRINT_CHARSPERLINE 32
val PRINT_WIDTH 4
val PRINT_HEIGHT 8
.include std/common.gxs
;.include std/int2str.gxs
.include std/print.gxs
.include std/mouse.gxs
.include std/button.gxs

; ______________________________________________________________________________
;

main:
	set %0 1
	st %0 SRAM_TOGGLE

loop:
	js updatemouse


; ______________________________________________________________________________
;
;  Draw wallpaper
;
;  %4 = X iterator
;  %5 = Y iterator
;  %6 = increment and draw size (constant 16)
;  %7 = maximum (constant 128)
;  %8 = wallpaper X in tileset (constant 112)
;  %9 = wallpaper Y in tileset (constant 32)
; ______________________________________________________________________________
;
	set %5 0
	set %6 16
	set %7 128
	set %8 112
	set %9 32

drawwpyloop:
	set %4 0

drawwpxloop:
	dw %8 %9 %6 %6
	at %4 %5

	add %4 %6 %4
	.ltj %4 %7 drawwpxloop

	add %5 %6 %5
	.ltj %5 %7 drawwpyloop
; ______________________________________________________________________________
;
;  Window drawing loop
;
;  %4 = current window being drawn (iterator)
;  %5 = constant 1
;  %6 = loop total (window count)
;  %7 %8 = current address being read
;  %9 = size of window data structure (constant 16)
;
;  %10 = current window X
;  %11 = current window Y
;  %12 = current window width
;  %13 = current window height
;  %14 = current window active flag
;  %15 %16 = current window update subroutine
; ______________________________________________________________________________
;
	set %4 0
	set %5 1
	set %6 lo(WINCOUNT)
	set %9 lo(WINSTRUCTSIZE)
drawloop:
	set %7 hi(WINADDR)  ; get current window's data structure's address
	set %8 lo(WINADDR)
	mul %4 %9 %3
	add %8 %3 %8

	ldi %10 %7     ; load window properties into registers: X
	add %8 %5 %8
	ldi %11 %7     ; Y
	add %8 %5 %8   
	ldi %12 %7     ; width
	add %8 %5 %8   
	ldi %13 %7     ; height
	add %8 %5 %8   
	ldi %14 %7     ; active flag

	cj %14 drawloopcontinue  ; if window is not active, skip it
	jmp drawloopskip

drawloopcontinue:
	add %8 %5 %8   
	ldi %15 %7     ; update sub (high)
	add %8 %5 %8   
	ldi %16 %7     ; update sub (low)
	add %8 %5 %8

	set %0 0         ; draw window titlebar
	set %1 119
	set %2 8
	dw %0 %1 %12 %2
	at %10 %11
; ______________________________________________________________________________
;
;  Draw window background
;  Draws a white strip (bottom pixel of tileset) for each pixel of window height
;  
;  %0 = loop increment and source height (constant 1)
;  %1 = source X (constant 0)
;  %2 = source Y (constant 127)
;  %3 = titlebar height (constant 8)
;  %17 = loop iterator (window Y + 8)
;  %18 = loop maximum (window Y + height)
; ______________________________________________________________________________
;
	set %0 1
	set %1 0
	set %2 127
	set %3 8
	.mov %11 %17
	.mov %11 %18
	add %17 %3 %17
	add %18 %13 %18
drawbgloop:
	dw %1 %2 %12 %0  ; draw a window width Ã— 1 area from (0, 127)
	at %10 %17       ; at (window X, iterator)

	add %17 %0 %17           ; next loop iteration
	.ltj %17 %18 drawbgloop
   
	.mov %7 %20   ; draw window title
	.mov %8 %21
	.mov %10 %22
	.mov %11 %23
	js print
; ______________________________________________________________________________
;
;  Draw close button, call window update subroutine, next loop iteration
; ______________________________________________________________________________
;
	add %10 %12 %17  ; draw close button
	set %0 8
	sub %17 %0 %17

	.mov %17 %20        ; X: window X + window width - 8 (calculated above)
	.mov %11 %21        ; Y: window Y
	set %22 60          ; sprite source X: 60
	set %23 32          ; sprite source Y: 32
	set %24 8           ; width: 8
	set %25 8           ; height: 8
	js button           ; create button
	cj %26 closewindow  ; if button was pressed, close window

	set %0 0            ; if window subroutine address is 0x0000, don't call it
	eq %15 %0 %1
	eq %16 %0 %2
	and %1 %2 %0
	cj %0 drawloopskip

	st %15 compjsh  ; call window update subroutine
	st %16 compjsl  ; note: subroutine should not modify registers %4 - %9
	js compjs

drawloopskip:
	add %4 %5 %4
	.ltj %4 %6 drawloop

	end
	jmp loop
; ______________________________________________________________________________
;

closewindow:
	set %7 hi(WINADDR)  ; get current window's data structure's address
	set %8 lo(WINADDR)
	mul %4 %9 %3
	add %8 %3 %8

	set %0 4      ; get the address of the window's active flag
	add %8 %0 %8

	set %0 0          ; set window's active flag to 0
	sti %0 %7
	jmp drawloopskip