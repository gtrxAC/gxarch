val BLOCK_BORDER_SX 8      ; border/background of currently selected block in HUD
val BLOCK_BORDER_SY 0      ; source X, source Y, width and height, dest X, dest Y
val BLOCK_BORDER_SIZE 12
val BLOCK_BORDER_X 78
val BLOCK_BORDER_Y 0

val SEL_BORDER_X 20       ; outline of block being pointed at
val SEL_BORDER_Y 0
val BLOCKS_Y 32           ; Y position of row containing block textures
val BG2_Y 96
val BG2_W 128
val BG2_H 16

render:
; ______________________________________________________________________________
;
;  Draw background
;
;  The background consists of two parts:
;  - Scrolling clouds (BG), top of screen
;  - Background color (BG2), bottom 16 pixels of the tileset are drawn on the
;    bottom part of the screen in a loop, solid color by default
; ______________________________________________________________________________
;
	{
		; Draw scrolling clouds (BG)
		reg bgx %0
		reg bgy %1
		reg bgw %2
		reg bgh %3

		val BG_Y 48   ; coordinates of BG (X is scrollcount)
		val BG_W 128
		val BG_H 48

		ld bgx scrollcount  ; draw clouds at current scroll count
		set bgy BG_Y        ; this works similarly to the drawscroll example, but
		set bgw BG_W        ; only horizontally scrolling and much slower, using
		set bgh BG_H        ; two counters (framecount and scrollcount), see
		dw bgx bgy bgw bgh  ; renderbg2loop
		at (%1:0) %1

		set bgx 0           ; set draw source for BG2
		set bgy BG2_Y       ; we only need to do this once and the at instruction
		set bgw BG2_W       ; will keep using the same source until we set a
		set bgh BG2_H       ; different source
		dw bgx bgy bgw bgh

		; Draw repeating background color (BG2)
		reg bg2iter %1
		reg bg2max %2

		set bg2iter BG_H  ; start drawing BG2 where BG ends
		set bg2max 128    ; and end where the screen ends (128px)
	renderbg2loop:
		at bgx bg2iter                     ; draw one strip of BG2 and loop
		add bg2iter bgh bg2iter
		.ltj bg2iter bg2max renderbg2loop
	}

	ld %0 framecount  ; increment frame count
	add %0 (%1:1) %0
	st %0 framecount

	div %0 (%2:CLOUDSPEED) %29  ; if framecount is divisible by CLOUDSPEED,
	.eqjs %r (%0:0) incscroll   ; increment cloud scroll count

; ______________________________________________________________________________
;
;  Draw blocks
; ______________________________________________________________________________
;
	{
		; Variables
		; if changing registers, also change them in drawindicator subroutine
		reg x %4       ; X/Y iterator
		reg y %5
		reg px %6      ; player X/Y
		reg py %7
		reg blockh %8  ; block address, high/low bytes
		reg blockl %9
		reg block %10  ; value at block address (block value/ID)
		reg mxb %20    ; mouse x/y block
		reg myb %21
		reg drawx %17  ; current draw location
		reg drawy %18
		reg tsx %19    ; tileset X to draw from

		; Constants
		reg _1 %11       ; 1
		reg BSIZE %12    ; block size
		reg ITERMAX %13  ; max X and Y iter (blocksize 10 * itermax = 130 needed to fill screen)
		reg WW %14       ; world width
		reg BY %15       ; tileset source Y for blocks

		set y 0             ; set initial values for variables
		ld px playerx
		ld py playery
		ld mxb mousexblock
		ld myb mouseyblock

		set _1 1             ; set constants
		set BSIZE BLOCKSIZE
		set ITERMAX 13
		set WW WWIDTH
		set BY BLOCKS_Y

	renderyloop:
		set x 0

	renderxloop:
		set blockh hi(blocks)  ; block address = starting address
		set blockl lo(blocks)

		add y py %0           ; block address += (iterator y + player y) * world width
		mul %0 WW %0
		add blockh %h blockh
		add blockl %0 blockl

		add blockl x blockl   ; block address += iterator x + player x
		add blockh %h blockh
		add blockl px blockl
		add blockh %h blockh

		ldi block blockh          ; load current block, skip drawing if it's air
		.eqj block (%0:0) renderskip

		set %0 BLOCKCOUNT         ; skip drawing if block id exceeds block count
		sub %0 _1 %0
		.gtj block %0 renderskip

		mul block BSIZE tsx    ; multiply the block's id by block size
		dw tsx BY BSIZE BSIZE  ; to get the tileset coordinate to draw from

		mul x BSIZE drawx  ; destination X/Y = iterator X/Y * block size
		mul y BSIZE drawy
		at drawx drawy     ; draw tile at destination X/Y

	renderskip:
		add x px %1           ; if this block is being pointed at (check both X and Y coordinates)
		eq %1 mxb %2
		add y py %1
		eq %1 myb %3
		and %2 %3 %1
		cjs %1 drawindicator  ; then draw an indicator

		add x _1 x                  ; next X iteration if row isn't done
		.ltj x ITERMAX renderxloop

		add y _1 y                  ; next Y iteration if drawing not finished
		.ltj y ITERMAX renderyloop
	}
; ______________________________________________________________________________
;
;  Draw HUD (player position and currently selected block)
; ______________________________________________________________________________
;
	ld arg0 playerx         ; format player X/Y into coordinate string
	set arg1 hi(COORDSTRX)
	set arg2 lo(COORDSTRX)
	js int2str

	ld arg0 playery
	set arg1 hi(COORDSTRY)
	set arg2 lo(COORDSTRY)
	js int2str

	set arg0 hi(coordstr)  ; print coordinate string in the top left corner
	set arg1 lo(coordstr)
	set arg2 0
	set arg3 2
	js print

	; draw border for current block
	dw (%0:BLOCK_BORDER_SX) (%1:BLOCK_BORDER_SY) (%2:BLOCK_BORDER_SIZE) %2
	at (%0:BLOCK_BORDER_X) (%1:BLOCK_BORDER_Y)

	; draw current block
	ld %0 curblock
	mul %0 %12 %0
	dw %0 (%1:BLOCKS_Y) (%2:BLOCKSIZE) %2
	at (%0:79) (%1:1)

	end
	jmp update

; ______________________________________________________________________________
;
;  Subroutines
; ______________________________________________________________________________
;

; Increment cloud scroll counter
incscroll:
	ld %0 scrollcount
	add %0 (%1:1) %0
	st %0 scrollcount
	ret

; Draw indicator for the block that is being pointed at
drawindicator:
	reg x %4       ; regs from draw blocks routine
	reg y %5
	reg BSIZE %12

	dw (%1:SEL_BORDER_X) (%2:SEL_BORDER_Y) BSIZE BSIZE
	mul x BSIZE %23
	mul y BSIZE %24
	at %23 %24
	ret