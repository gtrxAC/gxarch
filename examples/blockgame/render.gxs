val BLOCK_BORDER_X 8      ; border/background of currently selected block in HUD
val BLOCK_BORDER_Y 0
val BLOCK_BORDER_SIZE 12
val SEL_BORDER_X 20       ; outline of block being pointed at
val SEL_BORDER_Y 0
val BLOCKS_Y 32           ; Y position of row containing block textures
val BG_Y 48               ; The background consists of two parts: the scrolling
val BG_W 128              ; clouds (BG) and a repeating background color (BG2)
val BG_H 48
val BG2_Y 96
val BG2_W 128
val BG2_H 16

render:
	ld %0 scrollcount  ; draw clouds at current scroll count
	set %1 lo(BG_Y)    ; this works similarly to the drawscroll example, but
	set %2 lo(BG_W)    ; only horizontally scrolling and much slower, using
	set %3 lo(BG_H)    ; two counters (framecount and scrollcount), see
	dw %0 %1 %2 %3     ; renderbg2loop
	set %1 0
	at %1 %1

	set %0 0
	set %1 lo(BG2_Y)
	set %2 lo(BG2_W)
	set %3 lo(BG2_H)
	dw %0 %1 %2 %3

	set %1 lo(BG_H)
	set %2 128
renderbg2loop:
	at %0 %1
	add %1 %3 %1
	.ltj %1 %2 renderbg2loop

	ld %0 framecount  ; increment frame count
	set %1 1
	add %0 %1 %3
	st %3 framecount

	set %0 lo(CLOUDSPEED)  ; if framecount is divisible by CLOUDSPEED,
	div %3 %0 %29          ; increment cloud scroll count
	set %0 0
	.eqj %r %0 incscroll
	jmp noincscroll

incscroll:
	ld %0 scrollcount
	set %1 1
	add %0 %1 %3
	st %3 scrollcount

noincscroll:
	set %4 0  ; iterator X/Y
	set %5 0
	ld %6 playerx  ; player X/Y
	ld %7 playery
	; %8 %9 = current block address
	; %10 = current block value
	set %11 1              ; constants
	set %12 lo(BLOCKSIZE)
	set %13 13
	set %14 lo(WWIDTH)
	set %15 lo(BLOCKS_Y)
	; %16 = immediate
	; %17 %18 = current draw location
	; %19 = current tileset X to draw
	ld %20 mousexblock
	ld %21 mouseyblock

renderyloop:
	set %4 0

renderxloop:
	set %8 hi(blocks)  ; block address = starting address
	set %9 lo(blocks)

	add %5 %7 %16   ; block address += (iterator y + player y) * world width
	mul %16 %14 %16
	add %8 %h %8
	add %9 %16 %9

	add %9 %4 %9  ; block address += iterator x + player x
	add %8 %h %8
	add %9 %6 %9
	add %8 %h %8

	ldi %10 %8               ; load current block, skip drawing if it's air
	set %16 0
	.eqj %10 %16 renderskip

	set %16 lo(BLOCKCOUNT)   ; skip drawing if block id exceeds block count
	sub %16 %11 %16
	.gtj %10 %16 renderskip

	mul %10 %12 %19     ; multiply the block's id by block size
	dw %19 %15 %12 %12  ; to get the tileset coordinate to draw from

	mul %4 %12 %17  ; destination X/Y = iterator X/Y * block size
	mul %5 %12 %18
	at %17 %18      ; draw tile at destination X/Y

renderskip:
	add %4 %6 %16            ; is this block being pointed at?
	.eqj %16 %20 pointedatx  ; in X direction
	jmp notpointedat

pointedatx:
	add %5 %7 %16            ; in Y direction
	.eqj %16 %21 pointedaty
	jmp notpointedat

pointedaty:
	set %0 lo(SEL_BORDER_X)  ; if pointed at, draw an indicator
	set %1 lo(SEL_BORDER_Y)
	set %2 lo(BLOCKSIZE)
	dw %0 %1 %2 %2
	mul %4 %12 %23
	mul %5 %12 %24
	at %23 %24

notpointedat:
	add %4 %11 %4            ; next X iteration if row isn't done
	.ltj %4 %13 renderxloop

	add %5 %11 %5            ; next Y iteration if render not finished
	.ltj %5 %13 renderyloop

	ld %20 playerx         ; format player X/Y into coordinate string
	set %21 hi(COORDSTRX)
	set %22 lo(COORDSTRX)
	js int2str
	ld %20 playery
	set %21 hi(COORDSTRY)
	set %22 lo(COORDSTRY)
	js int2str

	set %20 hi(coordstr)  ; print coordinate string in the top left corner
	set %21 lo(coordstr)
	set %22 0
	set %23 2
	js print

	set %0 lo(BLOCK_BORDER_X)  ; draw border for current block
	set %1 lo(BLOCK_BORDER_Y)
	set %2 lo(BLOCK_BORDER_SIZE)
	dw %0 %1 %2 %2
	set %0 78
	set %1 0
	at %0 %1

	ld %0 curblock  ; draw current block
	mul %0 %12 %0
	set %1 lo(BLOCKS_Y)
	set %2 lo(BLOCKSIZE)
	dw %0 %1 %2 %2
	set %0 79
	set %1 1
	at %0 %1

	end
	jmp update