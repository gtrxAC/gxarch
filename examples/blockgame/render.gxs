val BLOCK_BORDER_SX 8     ; border/bg of currently selected block in HUD
val BLOCK_BORDER_SY 0     ; source X, Y, width and height, dest X, Y
val BLOCK_BORDER_SIZE 12
val BLOCK_BORDER_X 78
val BLOCK_BORDER_Y 0

val SEL_BORDER_X 20  ; outline of block being pointed at
val SEL_BORDER_Y 0
val BLOCKS_Y 32      ; Y position of row containing block textures

; ______________________________________________________________________________
;
;  Draw background
; ______________________________________________________________________________
;
render:
	; Draw clouds at current scroll count
	dw [%0:scrollcount] (%1:48) (%2:128) (%3:36)
	at (%1:0) %1

	; Increment frame count
	ld %0 framecount
	add %0 (%1:1) %0
	st %0 framecount

	; Increment cloud scroll count every CLOUDSPEED frames
	; (if framecounter is divisible by CLOUDSPEED)
	div %0 (%2:CLOUDSPEED) %29
	eqjs %r (%0:0) incscroll

; ______________________________________________________________________________
;
;  Draw blocks
; ______________________________________________________________________________
;
	{
		; Variables
		; If changing registers, also change them in drawindicator subroutine
		reg x %4       ; X/Y iterator
		reg y %5
		reg px %6      ; player X/Y
		reg py %7
		reg blockh %8  ; block address, high/low bytes
		reg blockl %9
		reg block %10  ; value at block address (block value/ID)
		reg mxb %20    ; mouse X/Y block
		reg myb %21
		reg drawx %17  ; current draw location
		reg drawy %18
		reg tsx %19    ; tileset X to draw from

		; Constants
		reg _1 %11       ; 1
		reg BSIZE %12    ; block size
		reg ITERMAX %13  ; max X and Y iter (blocksize 10 * itermax = 130 needed
		                 ; to fill screen)
		reg WW %14       ; world width
		reg BY %15       ; tileset source Y for blocks

		; Set initial values for variables
		set y 0
		ld px playerx
		ld py playery
		ld mxb mousexblock
		ld myb mouseyblock

		; Set constants
		set _1 1
		set BSIZE BLOCKSIZE
		set ITERMAX 13
		set WW WWIDTH
		set BY BLOCKS_Y

	renderyloop:
		set x 0

	renderxloop:
		; block address = starting address
		set blockh hi(blocks)
		set blockl lo(blocks)

		; block address += (iterator y + player y) * world width
		add y py %0
		mul %0 WW %0
		add blockh %h blockh
		add blockl %0 blockl

		; block address += iterator x + player x
		add blockl x blockl
		add blockh %h blockh
		add blockl px blockl
		add blockh %h blockh

		; Load current block, skip drawing if it's air
		ldi block blockh
		eqj block (%0:0) renderskip

		; Skip drawing if block id exceeds block count
		set %0 BLOCKCOUNT
		sub %0 _1 %0
		gtj block %0 renderskip

		; Multiply block ID by block size to get the tileset coords to draw from
		mul block BSIZE tsx
		dw tsx BY BSIZE BSIZE

		; destination X/Y = iterator X/Y * block size
		mul x BSIZE drawx
		mul y BSIZE drawy

		; Draw tile
		at drawx drawy

	renderskip:
		; If this block is being pointed at (check both X and Y coordinates),
		; draw an indicator
		add x px %1
		eq %1 mxb %2
		add y py %1
		eq %1 myb %3
		and %2 %3 %1
		cjs %1 drawindicator

		; next X iteration if row isn't done
		add x _1 x
		ltj x ITERMAX renderxloop

		; next Y iteration if drawing isn't finished
		add y _1 y
		ltj y ITERMAX renderyloop
	}
; ______________________________________________________________________________
;
;  Draw HUD (player position and currently selected block)
; ______________________________________________________________________________
;
	; Format player X/Y into coordinate string
	ld arg0 playerx
	set arg1 hi(COORDSTRX)
	set arg2 lo(COORDSTRX)
	js int2str

	ld arg0 playery
	set arg1 hi(COORDSTRY)
	set arg2 lo(COORDSTRY)
	js int2str

	; Print coordinate string in the top left corner
	set arg0 hi(coordstr)
	set arg1 lo(coordstr)
	set arg2 0
	set arg3 2
	js print

	; Draw border for current block
	dw (%0:BLOCK_BORDER_SX) (%1:BLOCK_BORDER_SY) (%2:BLOCK_BORDER_SIZE) %2
	at (%0:BLOCK_BORDER_X) (%1:BLOCK_BORDER_Y)

	; Draw current block
	ld %0 curblock
	mul %0 %12 %0
	dw %0 (%1:BLOCKS_Y) (%2:BLOCKSIZE) %2
	at (%0:79) (%1:1)

	end
	jmp update

; ______________________________________________________________________________
;
;  Subroutines
; ______________________________________________________________________________
;
; Increment cloud scroll counter
incscroll:
	ld %0 scrollcount
	add %0 (%1:1) %0
	st %0 scrollcount
	ret

; Draw indicator for the block that is being pointed at
drawindicator:
	reg x %4       ; regs from draw blocks routine
	reg y %5
	reg BSIZE %12

	dw (%1:SEL_BORDER_X) (%2:SEL_BORDER_Y) BSIZE BSIZE
	mul x BSIZE %23
	mul y BSIZE %24
	at %23 %24
	ret