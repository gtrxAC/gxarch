; Brownian Tree for gxarch
; Ported from http://rosettacode.org/wiki/Brownian_tree#BBC_BASIC
; Tip: use the emulator speed up feature (Insert key) to generate faster
; Date: 2022-01-06
; Author: gtrxAC

dat main
string: dat "Generating, may take a while"

val PRINT_CHARSPERLINE 32
val PRINT_WIDTH 4
val PRINT_HEIGHT 8
.include std/common.gxs
.include std/print.gxs

val GRIDW 128     ; The screen gets automatically cleared every frame, and cannot be read
val GRIDH 128     ; from, so we need to keep the generated bitmap data in our own buffer,
addr grid 0x4000  ; then draw it on screen after generating.
                  ; This is a 128 Ã— 128 bitmap (address 0x4000 to 0x7FFF),
                  ; each byte is one pixel.

; ______________________________________________________________________________
;
;  Bitmap utilities
; ______________________________________________________________________________
;

; Gets the address of a pixel. Used by setpixel and getpixel.
; %20 = X
; %21 = Y
; return value: %23 %24
pixeladdr:
	set %23 hi(grid)
	set %24 lo(grid)
	mul %21 (%0:GRIDH) %24
	add %23 %h %23
	add %24 %20 %24
	add %23 %h %23
	ret

; Sets a pixel to a value.
; %20 = X
; %21 = Y
; %22 = value (0 or 1)
; uses registers %23 %24
setpixel:
	js pixeladdr
	sti %22 %23
	ret

; Gets a pixel's value.
; %20 = X
; %21 = Y
; return value: %22
; uses register %23
getpixel:
	js pixeladdr
	ldi %22 %23
	ret

; ______________________________________________________________________________
;
;  Generate the tree
; ______________________________________________________________________________
;

main: {
	reg ih %13    ; declare variables
	reg il %14
	reg x %5
	reg y %6
	reg oldX %9
	reg oldY %10

	reg _1 %11      ; and constants
	reg _2 %8
	reg _3 %12
	reg _4 %7
	reg SIZE %4
	reg MAXITERH %15
	reg MAXITERL %16

	set SIZE 63     ; set constants
	set MAXITERH 5  ; max iterations is a 16-bit value, just like the iterator (ih, il)
	set MAXITERL 0  ; so we can have more than 256 iterations
	set _1 1
	set _2 2
	set _3 3
	set _4 4

	.mov SIZE arg0  ; set the seed (middle of screen)
	.mov SIZE arg1
	set arg2 2
	js setpixel

	iterloop:
		setinitialpos:
			ld %0 RAND   ; set x/y to a random initial position
			ld %1 RAND
			div %0 _2 x
			div %1 _2 y

		loop:
			.mov x oldX
			.mov y oldY

			ld %0 RAND    ; increment/decrement x and y randomly
			mul %0 _3 %0  ; generate random number 0 to 255, multiply by 3, get high byte
			sub %h _1 %0  ; of result (0-2), subtract 1, add that to x/y
			add x %0 x

			ld %0 RAND
			mul %0 _3 %0
			sub %h _1 %0
			add y %0 y

			.mov x arg0  ; if this pixel was already set, plot a pixel at oldX and oldY
			.mov y arg1  ; and go to next iteration
			js getpixel
			cj %22 plot
			jmp loop     ; if this pixel isn't set, try again

		plot:
			.mov oldX arg0  ; plot the result x/y in bitmap
			.mov oldY arg1
			set arg2 1
			js setpixel

			set arg0 hi(string)  ; draw "generating" string and result so far
			set arg1 lo(string)
			set arg2 0
			set arg3 0
			js print
			js drawresult

		add il _1 il               ; next iteration
		add ih %h ih
		.ltj ih MAXITERH iterloop
		.ltj il MAXITERL iterloop

done:
	js drawresult
	jmp done
}

; ______________________________________________________________________________
;
;  Rendering (subroutine)
; ______________________________________________________________________________
;

drawresult: {
	reg x arg0       ; X/Y are the same as arguments for getpixel
	reg y arg1
	reg pxvalue %22

	reg _1 %17    ; constants (1, width, height, 0)
	reg w %18
	reg h %19
	reg _0 %28

	set _0 0
	set _1 1
	set w GRIDW
	set h GRIDH

	set x 0         ; draw every pixel of the generated bitmap
xloop:
	set y 0
yloop:
	js getpixel
	dw pxvalue _0 _1 _1
	at x y
	add y _1 y
	.ltj y h yloop
	add x _1 x
	.ltj x w xloop

	end
	ret
}