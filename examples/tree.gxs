; Brownian Tree for gxarch
; Ported from http://rosettacode.org/wiki/Brownian_tree#BBC_BASIC
; Tip: use the emulator speed up feature (Insert key) to generate faster
; Date: 2022-01-06
; Author: gtrxAC

datl main       ; set program entry point
dat 0, 128, 64  ; set screen clear color (dark green)
dat 0           ; doesn't support save file

string: dat "Generating, may take a while"

val PRINT_CHARSPERLINE 32
val PRINT_WIDTH 4
val PRINT_HEIGHT 8
include "std/common.gxs"
include "std/print.gxs"

val GRIDW 128     ; The screen gets automatically cleared every frame, and cannot be read
val GRIDH 128     ; from, so we need to keep the generated bitmap data in our own buffer,
addr grid 0x4000  ; then draw it on screen after generating.
                  ; This is a 128 Ã— 128 bitmap (address 0x4000 to 0x7FFF),
                  ; each byte is one pixel.

; ______________________________________________________________________________
;
;  Bitmap utilities
; ______________________________________________________________________________
;
; Gets the address of a pixel. Used by setpixel and getpixel.
; %20 = X
; %21 = Y
; return value: %23 %24
pixeladdr:
	set %23 hi(grid)
	set %24 lo(grid)
	mul %21 (%0:GRIDH) %24
	add %23 %h %23
	add %24 %20 %24
	add %23 %h %23
	ret

; Sets a pixel to a value.
; %20 = X
; %21 = Y
; %22 = value (0 or 1)
; uses registers %23 %24
setpixel:
	js pixeladdr
	sti %22 %23
	ret

; Gets a pixel's value.
; %20 = X
; %21 = Y
; return value: %22
; uses register %23
getpixel:
	js pixeladdr
	ldi %22 %23
	ret

; ______________________________________________________________________________
;
;  Generate the tree
; ______________________________________________________________________________
;
main: {
	; Declare variables (registers)
	reg ih %13
	reg il %14
	reg x %5
	reg y %6
	reg oldX %9
	reg oldY %10

	; Declare constants
	reg _1 %11
	reg _2 %8
	reg _3 %12
	reg _4 %7
	reg SIZE %4
	reg MAXITERH %15
	reg MAXITERL %16

	; Set constants
	set SIZE 63
	set MAXITERH 5  ; max iterations is a 16-bit value, just like the iterator
	set MAXITERL 0  ; (ih, il), so we can have more than 256 iterations
	set _1 1
	set _2 2
	set _3 3
	set _4 4

	; Set the seed (middle of screen)
	mov SIZE arg0
	mov SIZE arg1
	set arg2 2
	js setpixel

	iterloop:
		setinitialpos:
			; Set X/Y to a random initial position
			ld %0 RAND
			ld %1 RAND
			div %0 _2 x
			div %1 _2 y

		loop:
			mov x oldX
			mov y oldY

			; Increment/decrement x and y randomly
			ld %0 RAND
			mul %0 _3 %0  ; generate random number 0 to 255, multiply by 3, take
			sub %h _1 %0  ; high byte (0-2), subtract 1, add that to x/y
			add x %0 x

			ld %0 RAND
			mul %0 _3 %0
			sub %h _1 %0
			add y %0 y

			; If this pixel was already set, plot a pixel at oldX and oldY and
			; go to next iteration
			mov x arg0
			mov y arg1
			js getpixel
			cj %22 plot
			jmp loop     ; if this pixel isn't set, try again

		plot:
			; Plot the result x/y in the bitmap
			mov oldX arg0
			mov oldY arg1
			set arg2 1
			js setpixel

			; Draw "generating" string and result so far
			set arg0 hi(string)
			set arg1 lo(string)
			set arg2 0
			set arg3 0
			js print
			js drawresult

		; Next iteration
		add il _1 il
		add ih %h ih
		ltj ih MAXITERH iterloop
		ltj il MAXITERL iterloop

done:
	js drawresult
	jmp done
}

; ______________________________________________________________________________
;
;  Rendering (subroutine)
; ______________________________________________________________________________
;

drawresult: {
	reg x arg0       ; X/Y are the same as arguments for getpixel
	reg y arg1
	reg pxvalue %22

	; Constants (1, width, height, 0)
	reg _1 %17
	reg w %18
	reg h %19
	reg _0 %28

	set _0 0
	set _1 1
	set w GRIDW
	set h GRIDH

	; Draw every pixel of the generated bitmap
	set x 0
xloop:
	set y 0
yloop:
	js getpixel
	dw pxvalue _0 _1 _1
	at x y
	add y _1 y
	ltj y h yloop
	add x _1 x
	ltj x w xloop

	end
	ret
}