input: {
; ______________________________________________________________________________
;
;  Scan user input
;  Sets curkey to pressed keycode, 0 if nothing pressed, ignores key repeat
;  Copied from examples/key.gxs
; ______________________________________________________________________________
;
	reg k %4  ; register for current key (also stored in RAM as curkey)
	set k 0

	; Check each key to find one that is pressed
	; see examples/key.gxs
	inputloop:
		key k %0
		cj %0 keyfound

		add k (%0:1) k
		.ltj k (%0:K_COUNT) inputloop

		st (%0:0) keyflag
		st %0 curkey
		jmp readinputdone

	keyfound:
		ld %0 keyflag  ; ignore repeated key
		cj %0 return

		st (%0:1) keyflag
		st k curkey
		jmp readinputdone

	; Skip input processing if no key was pressed
	readinputdone:
		ld k curkey
		.eqj k (%0:0) return

; ______________________________________________________________________________
;
;  Process user input
; ______________________________________________________________________________
;
	procinput:
		.mov k arg0  ; get key's hex value
		js hex2int4b

		.eqj arg1 (%0:16) procinput_nohex
		.mov arg1 k

		ld arg0 cursorx   ; get the address where to write
		ld arg1 cursorch
		ld arg2 cursory
		ld arg3 curpage
		js pos2addr

		sti k arg4  ; write to address
		js moveright
		ret

	; If key is not hex, check if it's P or an arrow key
	procinput_nohex:
		.eqj k (%0:K_LEFT) moveleft
		.eqj k (%0:K_RIGHT) moveright
		.eqj k (%0:K_UP) moveup
		.eqj k (%0:K_DOWN) movedown
		.eqj k (%0:K_P) toggleplay
		.eqj k (%0:K_p) toggleplay
		.eqj k (%0:K_PLUS) addpage
		.eqj k (%0:K_MINUS) removepage
		ret
}

toggleplay:
	ld %0 playing
	cj %0 toggleplayoff
	st (%0:1) playing
	ld %1 cursorx        ; copy editmode location into old location
	ld %2 cursorch       ; to be retrieved later when exiting playmode
	ld %3 cursory
	ld %4 curpage
	st %1 oldx
	st %2 oldch
	st %3 oldy
	st %4 oldpage
	st (%0:0) cursorx   ; start playing from the start of the track
	st (%0:0) cursorch
	st (%0:0) cursory
	st (%0:0) curpage
	ret

toggleplayoff:
	st (%0:0) playing
	ld %1 oldx         ; restore old location
	ld %2 oldch
	ld %3 oldy
	ld %4 oldpage
	st %1 cursorx
	st %2 cursorch
	st %3 cursory
	st %4 curpage

	snd (%0:0) %0 %0 %0  ; reset all audio channels
	snd (%1:1) %0 %0 %0
	snd (%1:2) %0 %0 %0
	snd (%1:3) %0 %0 %0
	ret

addpage:
	ld %1 pagecount
	add %1 (%0:1) %1
	.gtj %1 (%0:MAX_PAGES) return
	st %1 pagecount
	ret

removepage:
	ld %1 pagecount
	sub %1 (%0:1) %1
	.eqj %1 (%0:0) return
	ld %0 curpage
	.eqjs %0 %1 removepage_pageup  ; if on last page (after removing page, that
	st %1 pagecount                ; is out of bounds), go one page back
	ret

removepage_pageup:
	ld %2 curpage
	sub %2 (%0:1) %2
	st %2 curpage
	ret