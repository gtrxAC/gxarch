play: {
	reg x %4
	reg ch %5
	reg y %6

	reg snd0 %7  ; args for snd instruction
	reg snd1 %8
	reg snd2 %9

	reg addrh arg3  ; pos2addr result
	reg addrl arg4

	ld %1 framecount
	div %1 (%0:4) %29  ; only play every 4 frames
	cj %r return

	; read each byte for the current line and play the appropriate sounds
	ld y cursory
	set ch 0
	playloop:
		.mov x arg0   ; get the address for this line and channel
		.mov ch arg1
		.mov y arg2
		js pos2addr

		ldi snd0 addrh          ; load each sound attribute into registers
		add addrl (%0:1) addrl
		ldi snd1 addrh
		add addrl %0 addrl
		ldi snd2 addrh

		add snd0 snd1 %1         ; don't play if the channel is just 000
		add %1 snd2 %1
		.eqj %1 (%0:0) playskip

		mul snd0 (%0:16) snd0  ; data is stored in values 0x00 to 0x0F
		mul snd1 %0 snd1       ; multiply by 16 to make that up to 0xF0
		mul snd2 %0 snd2

		snd ch snd0 snd1 snd2

	playskip:
		add ch (%0:1) ch
		.ltj ch (%0:CHANNEL_COUNT) playloop

	add y (%0:1) y                        ; move cursor to next line
	.eqjs y (%0:TRACK_LENGTH) playerloop  ; loop when reaching the end
	st y cursory
	ret

playerloop:
	set y 0
	ret
}