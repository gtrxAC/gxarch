; ______________________________________________________________________________
;
;  Cursor movement subroutines
; ______________________________________________________________________________
;
{
	reg x %5
	reg ch %6
	reg y %7
	reg page %8

; Load cursor position into registers defined above
; Note: sets %1 to constant 1 for easy increment/decrement
loadpos:
	ld x cursorx
	ld ch cursorch
	ld y cursory
	ld page curpage
	set %1 1
	ret

; Store cursor position back into RAM
storepos:
	st x cursorx
	st ch cursorch
	st y cursory
	st page curpage
	ret

; ______________________________________________________________________________
;
;  Left
; ______________________________________________________________________________
;
moveleft:
	js loadpos
	sub x %1 x         ; decrement X
	cjs %h moveleftch  ; if X underflow, go to previous channel
	js storepos
	ret

moveleftch:
	set x 2           ; set X to end of the (previous) channel
	sub ch %1 ch      ; go to previous channel
	cjs %h movelefty  ; if channel underflow, go to previous line
	ret

movelefty:
	set ch 3             ; go to last channel of line
	sub y %1 y           ; go to previous line
	cjs %h moveleftpage  ; if line underflow, go to previous page
	ret

moveleftpage:
	set y 19             ; go to last line of page
	sub page %1 page     ; go to previous page
	cjs %h moveleftstop  ; if page underflow, stop
	ret

moveleftstop:
	set x 0     ; go to the beginning of the track (position 0 everything)
	set ch 0
	set y 0
	set page 0
	ret

; ______________________________________________________________________________
;
;  Right
;  Works mostly the same as left, except increment instead of decrement, and
;  check upper bounds instead of checking underflow
; ______________________________________________________________________________
;
moveright:
	js loadpos
	add x %1 x
	.eqjs x (%0:CHANNEL_LENGTH) moverightch
	js storepos
	ret

moverightch:
	set x 0
	add ch %1 ch
	.eqjs ch (%0:CHANNEL_COUNT) moverighty
	ret

moverighty:
	set ch 0
	add y %1 y
	.eqjs y (%0:PAGE_LENGTH) moverightpage
	ret

moverightpage:
	set y 0
	add page %1 page
	ld %0 pagecount
	.eqjs page %0 moverightstop
	ret

moverightstop:
	set x 2           ; go to end of previous page
	set ch 3
	set y 19
	sub page %1 page
	ret

; ______________________________________________________________________________
;
;  Up
; ______________________________________________________________________________
;
moveup:
	js loadpos
	sub y %1 y
	cjs %h moveleftpage  ; note: reusing horizontal movement sub
	js storepos
	ret

; ______________________________________________________________________________
;
;  Down
; ______________________________________________________________________________
;
movedown:
	js loadpos
	add y %1 y
	.eqjs y (%0:PAGE_LENGTH) moverightpage
	js storepos
	ret
}