; Paint for gxarch
; Draw on a 32 × 30 pixel canvas
; Left/right arrow to change color, left mouse to draw
; Date: 2021-12-03
; Author: gtrxAC

; Based on blockgame but simplified, no player movement, no runtime stdlib, etc.
; Canvas size, scale and color count can be changed below

; Note: save file supports max 64 × 60 pixel canvas (3840 bytes, 2× scale to fit screen)
; Note: color index 0 should be black, there is an optimization that skips drawing color 0 pixels
;       and the black background color shows through

.include std/common.gxs  ; common.gxs only has compile time definitions for keys and addresses

val CANVASW 32
val CANVASH 30
val SCALE 4        ; pixels are always 4× scaled (128 × 120)
val COLORCOUNT 15

addr ldowntime 0xE000  ; how long have left/right keys been pressed
addr rdowntime 0xE001
addr curcolor 0xE002

dat main     ; set program entry point
dat 0, 0, 0  ; set screen clear color (black)
dat 1        ; supports save file

; ______________________________________________________________________________
;
main:
	st (%0:2) curcolor     ; set current color to white

update:
	.keyj K_LEFT moveleft  ; if left key down, select previous color
	jmp nomoveleft

moveleft:
	ld %0 ldowntime       ; if left has been down for longer (key down timer > 0), ignore
	cj %0 checkmoveright

	ld %0 curcolor                 ; if color is already 0, ignore
	.eqj %0 (%1:0) checkmoveright
	sub %0 (%1:1) %0               ; decrement color
	st %0 curcolor

	ld %0 ldowntime     ; increment key down timer
	add %0 %1 %0
	st %0 ldowntime
	jmp checkmoveright

nomoveleft:
	st %8 ldowntime  ; reset key down timer


checkmoveright:
	.keyj K_RIGHT moveright  ; if right key down, select next color
	jmp nomoveright

moveright:
	ld %0 rdowntime   ; if right has been down for longer (key down timer > 0), ignore
	cj %0 checkmouse

	ld %0 curcolor         ; if color is already COLORCOUNT - 1, ignore
	set %1 COLORCOUNT
	sub %1 (%2:1) %1
	.eqj %0 %1 checkmouse
	add %0 (%1:1) %0       ; increment color
	st %0 curcolor

	ld %0 rdowntime  ; increment key down timer
	add %0 (%1:1) %0
	st %0 rdowntime
	jmp checkmouse

nomoveright:
	st %8 rdowntime  ; reset key down timer


checkmouse:
	ld %0 MOUSEL
	cj %0 mousedown
	jmp draw

mousedown:
	set %0 hi(SRAM)  ; init address to write to (0xF000 start of SRAM)
	set %1 lo(SRAM)

	ld %2 MOUSEX          ; get mouse coordinates divided by scale
	ld %3 MOUSEY          ; to get X/Y of pixel pointed at
	div %2 (%4:SCALE) %2
	div %3 %4 %3

	mul %3 (%5:CANVASW) %1  ; add (pixel Y * canvas width) to address
	add %0 %h %0

	add %1 %2 %1  ; add pixel X to address
	add %0 %h %0

	ld %2 curcolor  ; write current color to address
	sti %2 %0
; ______________________________________________________________________________
;
draw: {
	reg x %0
	reg y %1
	reg curh %2
	reg curl %3
	reg _1 %4
	reg scale %5
	reg w %6
	reg h %7
	reg _0 %8
	reg px %9
	reg dstx %10
	reg dsty %11

	set x 0            ; iterator X/Y
	set y 0
	set curh 0            ; current pixel address
	set curl 0
	set _1 1            ; constants
	set scale SCALE
	set w CANVASW
	set h CANVASH
	; %8 = constant 0
	; %9 = loaded pixel value
	; %10 %11 = iterator X/Y * scale (draw destination)

drawyloop:
	set x 0

drawxloop:
	set curh hi(SRAM)  ; init address to read (0xF000 start of SRAM)
	set curl lo(SRAM)

	mul y w curl      ; add (pixel Y * canvas width) to address
	add curh %h curh

	add curl x curl   ; add pixel X to address
	add curh %h curh

	ldi px curh          ; load pixel from address
	.eqj px _0 drawnext  ; if black pixel, skip

	mul px scale px  ; multiply color value by scale to get the source X from tileset

	dw px _0 scale scale  ; draw pixel
	mul x scale dstx
	mul y scale dsty
	at dstx dsty

drawnext:
	add x _1 x          ; next X/Y loop iteration
	.ltj x w drawxloop

	add y _1 y
	.ltj y h drawyloop

	ld x curcolor     ; draw currently selected color below canvas
	set y 8
	mul x y x
	set y SCALE
	set curh 8
	dw x y curh curh
	set x 120
	at _0 x
}
	end
	jmp update